# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ...core.datetime_utils import serialize_datetime
from .bulk_data_export_deleted import BulkDataExportDeleted
from .bulk_data_export_error import BulkDataExportError
from .bulk_data_export_output import BulkDataExportOutput
from .bulk_data_export_status import BulkDataExportStatus
from .code import Code
from .id import Id
from .instant import Instant
from .meta import Meta
from .uri import Uri

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class BulkDataExport(pydantic.BaseModel):
    """
    User specific configuration for the Medplum application.
    """

    resource_type: typing.Literal["BulkDataExport"] = pydantic.Field(alias="resourceType")
    id: typing.Optional[Id] = pydantic.Field(
        default=None,
        description="The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.",
    )
    meta: typing.Optional[Meta] = pydantic.Field(
        default=None,
        description="The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.",
    )
    implicit_rules: typing.Optional[Uri] = pydantic.Field(
        alias="implicitRules",
        default=None,
        description="A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.",
    )
    language: typing.Optional[Code] = pydantic.Field(
        default=None, description="The base language in which the resource is written."
    )
    status: BulkDataExportStatus = pydantic.Field(description="The status of the request.")
    request_time: Instant = pydantic.Field(
        alias="requestTime", description="Indicates the server's time when the query is requested."
    )
    transaction_time: typing.Optional[Instant] = pydantic.Field(
        alias="transactionTime",
        default=None,
        description="Indicates the server's time when the query is run. The response SHOULD NOT include any resources modified after this instant, and SHALL include any matching resources modified up to and including this instant.",
    )
    request: Uri = pydantic.Field(
        description="The full URL of the original Bulk Data kick-off request. In the case of a POST request, this URL will not include the request parameters."
    )
    requires_access_token: typing.Optional[bool] = pydantic.Field(
        alias="requiresAccessToken",
        default=None,
        description="Indicates whether downloading the generated files requires the same authorization mechanism as the $export operation itself.",
    )
    output: typing.Optional[typing.List[BulkDataExportOutput]] = pydantic.Field(
        default=None,
        description="An array of file items with one entry for each generated file. If no resources are returned from the kick-off request, the server SHOULD return an empty array.",
    )
    deleted: typing.Optional[typing.List[BulkDataExportDeleted]] = pydantic.Field(
        default=None, description="An array of deleted file items following the same structure as the output array."
    )
    error: typing.Optional[typing.List[BulkDataExportError]] = pydantic.Field(
        default=None, description="Array of message file items following the same structure as the output array."
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        allow_population_by_field_name = True
        json_encoders = {dt.datetime: serialize_datetime}
